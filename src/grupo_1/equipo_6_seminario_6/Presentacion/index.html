<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>LINQ</title>

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<link rel="icon" href="assets/csharp.png" type="image/x-icon">
    	<link rel="icon" href="favicon.icns">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/league.css" id="theme">
		<link rel="stylesheet" href="lib/css/arduino-light.css">

		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<script src="plugin/highlight/highlight.js"></script>
	</head>

	<body>

		<div class="reveal">
			<div class="slides">
				<section data-background="assets/csharp.png" data-background-size="750px">
				</section>
				<section>
					<h1>LINQ y Métodos extensores</h1>
						<small> Equipo 6:
							<lu>
								<li>Yenli Gil Machado</li>
								<li>Yunior Alexander Tejeda Illana</li>
								<li>Juan José López Martínez</li>
								<li>Carlos Aryam Martínez Molina</li>
								<li>Ariel Plasencia Díaz</li>
							</lu>
						</small>
				</section>
				<section>
					<section>
						<h2>¿Dónde y cuándo surge LINQ?</h2>
					</section>
					<section>
						<ul>
							<li>Surge en el Framework 3.5 y pronto 
								coge una gran aceptación en el
								mundo .NET.
							</li>
							<li>En 2008 es incorporado a C# 3.0.</li>
							<li>Desde su surgimiento estuvo 
								vinculado a herramientas como 
								expresiones lambda, inferencia de 
								tipos, métodos extensores y tipos 
								anónimos.
							</li>
						</ul>
					</section>
					<section>
						<h2>¿Qué deberías conocer de LINQ?</h2>
					</section>
					<section>
						<ul>
							<li>Su significado por sus siglas es 
								Language Integrated Query (Lenguaje 
								Integrado de Consultas).</li>
							<li>Son un conjunto de herramientas de 
								Microsoft para realizar todo tipo de 
								consultas a distintas fuentes de 
								datos como objetos, xmls y 
								bases de datos. 
							</li>
							<li>Todas las variables de las 
								expresiones de consulta están 
								fuertemente	tipadas, por lo que en 
								muchos casos no es necesario 
								proporcionar el tipo explícitamente 
								porque el compilador puede inferirlo.
							</li>
						</ul>
					</section>
					<section>
						<ul>
							<li>
								La sintaxis es parecida a la 
								existente en SQL, pero con la 
								ventaja de que tenemos la potencia 
								de .NET y Visual Studio a la hora 
								de codificar.
							</li>
							<li>
								En tiempo de compilación, la 
								sintaxis de consulta se convierte 
								en llamadas de métodos a la 
								implementación de un proveedor de 
								LINQ de los métodos de extensión 
								de consulta estándar.
							</li>
							<li>
								Las expresiones de consulta son 
								fáciles de controlar porque 
								utilizan muchas construcciones de 
								lenguaje C#.
							</li>
							<li>
								Una consulta no se ejecuta hasta 
								que no se realiza la iteración a 
								través de la variable de consulta.
							</li>
						</ul>
					</section>
					<section>
						<h2>Ejemplos</h2>
						<pre class="LINQ hljs" data-trim><code>
Student[] equipo6 =
{
   new Student("Yenli", "Gil", 412, 22),
   new Student("Yunior", "Tejeda", 412, 24),
   new Student("Jotica", "Lopez", 311, 22),
   new Student("Carlos", "Martinez", 411, 23),
   new Student("Ariel", "Plasencia", 311, 23)
};
						</code></pre>
					</section>
					<section>
						<h2>Ejemplos</h2>
						<pre class="LINQ hljs" data-trim><code>var consulta1 = from est in equipo6
		orderby est.Age descending
		select new { Nombre = est.Name,Edad = est.Age };
foreach (var e in consulta1)
   Console.WriteLine("{0} {1}", e.Nombre, e.Edad);

var consulta2 = from est in equipo6
		group est by est.Age into groups
		orderby groups.Key ascending
		select groups;
foreach (var group in consulta2) {
   Console.WriteLine("Con {0} años", group.Key.ToString());
   foreach (var est in group)
      Console.WriteLine("  " + est.Name);
}                              
						</code></pre>
					</section>
					<section data-background="assets/output_linq.jpg" data-background-size="750px">
					</section>
					<section>
						<p>
							¿Qué hacen las siguientes líneas?
						</p>
						<pre class="LINQ hljs" data-trim><code>
int[] numeros = { 15, 14, ..., 2, 1 };
numeros.OrderBy(i => i).Where(i => i % 2 == 0)
		.OrderByDescending(i => i % 3 == 0).ToList()
		.ForEach((i) => Console.WriteLine(i));
						</code></pre>
					</section>
					<section>
						<p>
							Imprimen todos los números ordenados y 
							pares entre 1 y 15, primeramente los 
							múltiplos de 3 y luego los restantes.
						</p>
						<pre class="LINQ hljs" data-trim><code>
int[] numeros = { 15, 14, ... , 2, 1 };
numeros.OrderBy(i => i).Where(i => i % 2 == 0)
		.OrderByDescending(i => i % 3 == 0).ToList()
		.ForEach((i) => Console.WriteLine(i));

// OUTPUT
// 6
// 12
// 2
// 4
// 8
// 10
// 14
						</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Métodos extensores</h2>
						<h4>Nos permiten extender o agregar 
							funcionalidades a una clase ya existente 
							sin necesidad de usar la herencia o 
							polimorfismo.
						</h4>
					</section>
					<section>
						<h2>Sintaxis</h2>
						<ul>
							<li>
								Los métodos de extensión se definen 
								como métodos estáticos pero se 
								llaman utilizando la sintaxis de los 
								métodos de instancia.
							</li>
							<li>
								El primer parámetro especifica en 
								qué tipo actúa el método y va 
								precedido del modificador this.
							</li>
							<li>
								Se define dentro de una clase 
								estática y no genérica.
							</li>
						</ul>
					</section>
					<section>
						<h2>Estructura</h2>
						<pre class="LINQ hljs" data-trim><code>
public static class MetodosExtensores
{
   public static [tipo_metodo] NombreMetodo
 	(this [tipo_a_extender] nombre_instancia, args...)
   {
      // Código
      ...
   }
}
						</code></pre>
					</section>
					<section>
						<h2>Ejemplo</h2>
						<pre class="LINQ hljs" data-trim><code>
public static class MetodosExtensores
{
   public static int WordCount(this string str)
   {
      return str.Split(' ').Length;
   }
}
						</code></pre>
					</section>
					<section>
						<h2>¿Qué desventajas tienen el uso de 
							métodos extensores en C#?</h2>
						<ul>
							<li>
								La forma en la que los métodos 
								extensores son importados. Es
								imposible obtener un método 
								extensor de un namespace evitando 
								cargar completamente el mismo.
							</li>
							<li>
								Solo puedes tener métodos extensores, 
								ni propiedades, ni indexadores, ni 
								operadores, ni constructores extensores.
							</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h2>Ejercicio 1</h2>
						<p>
							Brinde una implementación eficiente y 
							simple del siguiente método extensor y 
							analice el costo operacional para el 
							caso peor:
						</p>	
					</section>
					<section data-background="assets/my_group_by.jpg" data-background-size="750px">
					</section>
					<section>
						<h2>Complejidad Temporal</h2>
						<p>Primero tenemos un ciclo que pasa por todos los elementos del
							IEnumerable source que tiene costo operacional O(n), luego dentro del 
							ciclo preguntamos si está la llave del item que estamos analizando en 
							esa iteración, lo cual es O(n). Junto al método where de LINQ
							que devuelve un IEnumerable con todos los elementos de source con llave
							igual a la de item que añade un costo de O(n). Por tanto el algoritmo seria
							O(n*(n + n)) que es O(n^2).

						</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Ejercicio 2</h2>
						<p>
							¿Se explotaría en su totalidad una 
							implementación “Lazy” del GroupBy?
							¿El costo de las operaciones para el 
							caso peor es el mismo independientemente 
							de si se hace un Take(k)?
						</p>
					</section>
					<section data-background="assets/my_group_by_lazy.jpg" data-background-size="750px">
					</section>
				</section>
				<section>
					<section>
						<h2>Ejercicio 3</h2>
						<p>
							Rescriba el siguiente código de forma tal 
							que siga manteniendo el while(true) pero 
							que permita “parar” la ejecución del 
							método para un momento dado:
						</p>
					</section>
					<section data-background="assets/get_primes.jpg" data-background-size="750px">
					</section>
					<section data-background="assets/get_primes_lazy.jpg" data-background-size="750px">
					</section>
					<section>
						<h2>Pregunta</h2>
						<p>
							¿Por qué la siguiente sentencia no 
							bloquea el programa?
						</p>
						<pre class="LINQ hljs" data-trim><code>
GetPrimes().Where(p => p.ToString().StartsWith("2")).Take(10);
						</code></pre>
					</section>
					<section data-background="assets/main1.jpg" data-background-size="750px">
					</section>
					<section data-background="assets/main2.jpg" data-background-size="750px">
					</section>
					<section data-background="assets/primes_out.jpg" data-background-size="750px">
					</section>
				</section>
				<section>
					<section>
						<h2>Ejercicio 4</h2>
						<p>
							Convierta el siguiente código Haskell a C#:
						</p>
						<pre class="LINQ hljs" data-trim><code>
four :: Integer -> Integer
four x = 4

infinity :: Integer
infinity = 1 + infinity
							</code></pre>
					</section>
					<section>
						<p>
							Aspectos a destacar en Haskell
						</p>
						<ul>
							<li>
								Su nombre se debe al lógico 
								estadounidense Haskell Curry, 
								debido a su aportación al cálculo 
								lambda, el cual tiene gran 
								influencia en el lenguaje.
							</li>
							<li>
								Es un lenguaje de programación 
								estandarizado y multi-propósito, 
								funcionalmente puro, con evaluación 
								no estricta y memorizada.
							</li>
							<li>
								Posee tipado estático.
							</li>
							<li>
								Tiene soporte para tipos de datos, 
								funciones recursivas, listas y 
								tuplas.
							</li>
							<li>
								Las variables son inmutables.
							</li>
						</ul>
					</section>
					<section>
						<ul>
							<li>
								Las funciones son ciudadanos de 
								primera clase.
							</li>
							<li>
								Inferencia de tipos.
							</li>
							<li>
								Discrimina entre mayúsculas y 
								minúsculas.
							</li>
							<ul>
								<li>
									El nombre de las variables deben 
									comenzar siempre con mayúsculas.
								</li>
								<li>
									El nombre de los tipos deben 
									comenzar con mayúsculas, a no 
									ser que se trate de un tipo 
									genérico.
								</li>
								<li>
									El nombre de los constructores 
									de tipos deben comenzar siempre 
									con mayúsculas.
								</li>
								<li>
									El nombre de las funciones 
									debe empezar siempre con 
									minúsculas.
								</li>
							</ul>
						</ul>
					</section>
					<section data-background="assets/haskell1.jpg" data-background-size="750px">
					</section>
					<section data-background="assets/haskell2.jpg" data-background-size="750px">
					</section>
				</section>
				<section>
					<section>
						<h2>Ejercicio 5</h2>
						<p>
							¿Son equivalentes los siguientes códigos?
						</p>
						<pre class="LINQ hljs" data-trim><code>
if(Cond1() | Cond2()) {
   Console.WriteLine("TRUE");
}
else {
   Console.WriteLine("FALSE");
}

if(Cond1() || Cond2()) {
   Console.WriteLine("TRUE");
}
else {
   Console.WriteLine("FALSE");
}
							</code></pre>
					</section>
					<section>
						<h2>Solución</h2>
						<p>
							¿Son equivalentes los siguientes códigos?
						</p>
						<pre class="LINQ hljs" data-trim><code>
string[] names = { "Yenli","Yunior","Jotica","Carlos","Ariel" };

if(names[0] == "Yenli" | names[5] == "Jotica")
   Console.WriteLine("TRUE");
else
   Console.WriteLine("FALSE");

if(names[0] == "Yenli" || names[5] == "Jotica")
   Console.WriteLine("TRUE");
else
   Console.WriteLine("FALSE");
							</code></pre>
					</section>
					<section>
						<h2>Solución</h2>
						<p>
							¿Son equivalentes los siguientes códigos?
						</p>
						<pre class="LINQ hljs" data-trim><code>
string[] names = { "Yenli","Yunior","Jotica","Carlos","Ariel" };

// EXCEPCION INDICE FUERA DE RANGO
//if(names[0] == "Yenli" | names[5] == "Jotica")
//   Console.WriteLine("TRUE");
//else
//   Console.WriteLine("FALSE");

if(names[0] == "Yenli" || names[5] == "Jotica")
   Console.WriteLine("TRUE");
else
   Console.WriteLine("FALSE");
							</code></pre>
					</section>
					<section>
						<h2>Solución</h2>
						<p>
							¿Son equivalentes los siguientes códigos?
						</p>
						<pre class="LINQ hljs" data-trim><code>
string[] names = { "Yenli","Yunior","Jotica","Carlos","Ariel" };

// EXCEPCION INDICE FUERA DE RANGO
//if(names[0] == "Yenli" | names[5] == "Jotica")
//   Console.WriteLine("TRUE");
//else
//   Console.WriteLine("FALSE");

// IMPRIME TRUE
if(names[0] == "Yenli" || names[5] == "Jotica")
   Console.WriteLine("TRUE");
else
   Console.WriteLine("FALSE");
							</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Ejercicio 6</h2>
						<p>
							Explique cómo funciona yield return en 
							C#. ¿Cómo se logra este comportamiento? 
							¿En Java existe algun mecanismo análogo?
						</p>
					</section>
					<section>
						<p>
							Un iterador es un método o propiedad implementado con un bloque iterador(iterator block), que a su vez es solo un bloque de código que utiliza las declaraciones de yield return o yield break. Los iterators blocks solo se pueden usar para implementar métodos o propiedades con uno de los siguientes tipos de retorno:
						</p>
					</section>
					<section>
						<ul>
							<li>
								IEnumerator
							</li>
							<li>
								IEnumerable
							</li>
							<li>
								IEnumerable[T] (donde T puede ser un parámetro de tipo o un tipo regular)
							</li>
							<li>
								En IEnumerator[T] (donde T puede ser un parámetro de tipo o un tipo regular)
							</li>
						</ul>
					</section>
					<section>
						<p>
							Vean que al usar la palabra yield ya no es necesaria la implementación de los métodos de IEnumerator superando la limitación anterior en C# que forzaba a estar definiendo clases IEnumerable sólo con la intención de devolver un IEnumerator a través del método GetEnumerator.
						</p>
					</section>
					<section>
						<p>
							A modo de resumen la inclusión de los iteradores en C#2 aumenta la expresividad y elegancia del código. Esta capacidad de iteradores se potencia al máximo cuando sea utilizada en combinación con la genericidad. Con genericidad un iterador podrá devolver un objeto de tipo IEnumerator<T> lo que significa que el compilador estáticamente garantizará que el objeto que devuelva un yield return tenga que ser
							de tipo T y que los elementos sobre los que se itere en el foreach sean de tipo T. Lo cual redunda en mayor legibilidad, más robustez y más eficiencia al disminuir la necesidad de operaciones de casting en tiempo de ejecución.	
						</p>
					</section>
				</section>
				<section data-background="assets/muchas_gracias.jpg" data-background-size="750px">
				</section>
				<canvas class="fireworks"></canvas>
			</div>
		</div>
		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/search/search.js', async: true },
					{ src: 'plugin/anime-js/anime.min.js' },
					{ src: 'plugin/anime-js/fireworks.js' },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
